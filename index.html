<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WikiPeople Graph</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            background-color: #201515;
            color: #ccc; 
        }
        .links line { stroke: #d8ff4d; stroke-opacity: 0.7; }
        .links line.oneway { stroke: #999; stroke-dasharray: 4,4; stroke-opacity: 0.4; }
        .node-circle { stroke: #fff; stroke-width: 1.5px; cursor: pointer; }
        .nodes-and-labels g text { fill: #ccc; font-size: 10px; pointer-events: none; text-anchor: middle; font-family: 'Press Start 2P', cursive; }

        #tooltip { position: absolute; opacity: 0; background-color: #333; color: white; padding: 8px 12px; border-radius: 6px; pointer-events: none; transition: opacity 0.2s; font-size: 0.875rem; font-family: sans-serif; }
        #search-container { position: absolute; top: 10px; left: 10px; z-index: 10; }
        #search-button, #randomize-button { 
            background-color: #d8ff4d; color: #1a1a1a; transition: background-color 0.2s;
            font-family: 'Press Start 2P', cursive; padding-top: 6px; padding-bottom: 6px;
            font-size: 14px; margin-left: 8px;
        }
        #search-button:hover, #randomize-button:hover { background-color: #b8cc3d; }
        #search-input { font-family: 'Press Start 2P', cursive; font-size: 14px; width: 350px; }
        #search-loading { display: none; margin-left: 10px; font-style: normal; color: #aaa; font-size: 10px;}
        #search-message, #initial-message { font-family: 'Press Start 2P', cursive; font-size: 8px; margin-top: 4px; min-height: 1.2em; }
        #search-message a { color: #61dafb; text-decoration: underline; cursor: pointer; }
        #search-message a:hover { color: #fff; }

        #stats-container {
            position: absolute; top: 10px; right: 10px; background-color: rgba(40, 40, 40, 0.8);
            padding: 10px; border-radius: 8px; z-index: 10; font-size: 10px; line-height: 1.4;
            min-width: 200px; max-width: 300px; color: #eee; font-family: 'Press Start 2P', cursive;
            transition: height 0.3s ease-out;
            height: auto;
        }
        #stats-container h3 { 
            font-size: 12px; margin-bottom: 5px; color: #d8ff4d; border-bottom: 1px solid #555; padding-bottom: 3px;
            cursor: pointer; user-select: none;
        }
        #stats-container.collapsed {
            height: 35px;
            overflow: hidden;
            padding-bottom: 5px;
        }
         #stats-description {
             margin-top: 8px; font-size: 9px; color: #bbb; border-top: 1px solid #555; padding-top: 5px;
             max-height: 120px; overflow-y: auto;
         }
        #stats-chart-area {
            margin-top: 10px;
            padding-top: 5px;
            border-top: 1px solid #555;
            padding-bottom: 5px; 
        }
        #leaderboard-container {
            position: absolute; bottom: 10px; left: 10px; background-color: rgba(40, 40, 40, 0.8);
            padding: 10px; border-radius: 8px; z-index: 10; font-size: 10px; line-height: 1.4;
            max-height: 30vh; color: #eee; font-family: 'Press Start 2P', cursive;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        #leaderboard-container.collapsed {
            max-height: 35px;
            overflow: hidden;
        }
        #leaderboard-container h3 { 
            font-size: 12px; margin-bottom: 5px; color: #d8ff4d; border-bottom: 1px solid #555; padding-bottom: 3px;
            cursor: pointer; user-select: none;
        }
         #leaderboard-container ol { list-style-position: inside; padding-left: 0; }
         #leaderboard-container li { margin-bottom: 2px; }
         #leaderboard-container li span { color: #aaa; margin-left: 5px; }
        
        #leaderboard-container li { 
            margin-bottom: 2px; 
            cursor: pointer; 
            transition: color 0.2s;
        }
        #leaderboard-container li:hover {
            color: #d8ff4d; 
        }
        #leaderboard-container li span { color: #aaa; margin-left: 5px; }

         #loading { font-family: 'Press Start 2P', cursive; }
         #footer-attribution {
             position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); width: 100%; text-align: center; 
             font-size: 8px; color: #777; z-index: 5; font-family: 'Press Start 2P', cursive;
         }
         #explanation-container {
            position: absolute; bottom: 10px; right: 10px; background-color: rgba(40, 40, 40, 0.8);
            padding: 10px; border-radius: 8px; z-index: 10; font-size: 10px; line-height: 1.4;
            max-width: 250px; color: #eee; font-family: 'Press Start 2P', cursive;
         }
         #explanation-toggle { font-size: 12px; margin-bottom: 5px; color: #aaa; cursor: pointer; border-bottom: 1px solid #555; padding-bottom: 3px; user-select: none; }
         #explanation-toggle::after { content: ' [+]'; font-size: 10px; }
         #explanation-container.expanded #explanation-toggle::after { content: ' [-]'; }
         #explanation-content { display: none; margin-top: 5px; }


    </style>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BVEG40EVEG"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-BVEG40EVEG');
    </script>

</head>
<body class="h-full text-gray-100">

    
    <div id="search-container">
        <input type="text" id="search-input" placeholder="Enter root person..." class="px-2 py-1 rounded border border-gray-600 bg-gray-700 text-white focus:outline-none focus:border-blue-500">
        <button id="search-button" class="px-3 py-1 rounded font-semibold">Visualize</button>
        <button id="randomize-button" class="px-3 py-1 rounded font-semibold">Randomize</button>
        <span id="search-loading">Processing...</span>
        <div id="initial-message" class="text-xs text-red-400 mt-1 h-4">
        </div>
        <div id="search-message" class="text-xs text-lime-400 mt-1 h-4"></div> 
    </div>

    <div id="stats-container">
        <h3 onclick="toggleContainer('stats-container')">Person Statistics</h3>
        <div id="stats-content">Select a person...</div>
        <div id="stats-chart-area"></div> 
        <div id="stats-description"></div>
    </div>

    <div id="footer-attribution">
        WikiPeople by the frog society
    </div>

    <div id="leaderboard-container">
        <h3 onclick="toggleContainer('leaderboard-container')">Top Mentions</h3>
        <ol id="leaderboard-list"><li>Loading...</li></ol>
    </div>


    <svg id="graph-viz" class="w-full h-full"></svg>
    <div id="tooltip"></div>
    <div id="loading" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-xl md:text-2xl">
        Wikipeople
    </div>

    <div id="explanation-container">
        <h3 id="explanation-toggle">Graph Logic</h3>
        <div id="explanation-content">
            Shows searched person (root) & everyone they link to OR who links to them.
            <br><br>
            - <span style="color:#d8ff4d"><b>Solid Lines:</b></span> Mutual link (A ↔ B).
            <br>
            - <span style="color:#999"><b>Dotted Lines:</b></span> One-way link (A → B, but B <span style="text-decoration: line-through;">↔</span> A in subgraph).
            <br><br>
            Node colors show relationship to current root:
            <br>
            <span style="color:#d8ff4d">Root</span>, 
            <span style="color:#ff7f0e">Mutual</span>, 
            <span style="color:#2ca02c">Links To Root</span>, 
            <span style="color:#1f77b4">Linked By Root</span>. 
        </div>
    </div>


    <script>
        const svg = d3.select("#graph-viz");
        const loadingText = d3.select("#loading");
        const width = +svg.node().getBoundingClientRect().width;
        const height = +svg.node().getBoundingClientRect().height;
        const tooltip = d3.select("#tooltip");
        const searchLoading = d3.select("#search-loading");
        const searchMessage = d3.select('#search-message');
        const initialMessageDiv = d3.select('#initial-message');
        const statsContentDiv = d3.select('#stats-content');
        const leaderboardListOl = d3.select('#leaderboard-list');
        const explanationContainer = d3.select('#explanation-container');
        const explanationToggle = d3.select('#explanation-toggle');
        const explanationContent = d3.select('#explanation-content');
        const randomizeButton = d3.select('#randomize-button');
        const statsDescriptionDiv = d3.select('#stats-description');
        const statsContainer = d3.select('#stats-container');
        const leaderboardContainer = d3.select('#leaderboard-container');


        const nodeColors = {
            "root": "#d8ff4d",           // (Lime Green)
            "mutual_neighbor": "#ff7f0e", // (Orange)
            "in_neighbor": "#2ca02c",    // (Dark Green)
            "out_neighbor": "#1f77b4"     // (Blue)
         };
        const defaultRoot = "Michael Stevens"; // (Vsauce)
        const LEADERBOARD_SIZE = 10;
        const SUGGESTION_THRESHOLD = 3; // Max Levenshtein distance
        const RICK_ROLL_URL = "https://www.youtube.com/watch?v=dQw4w9WgXcQ";
        const DISTRIBUTION_BINS = [0, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000];
        
        let fullGraphData = null;
        let fullNodesMap = new Map();
        let fullAdj = new Map();
        let fullRevAdj = new Map();
        let inDegrees = new Map();
        let outDegrees = new Map();
        let rankedNodes = [];
        let allNodeNames = []; 
        let distributionData = [];

        let simulationInstance = null;
        let nodeGroupSelection = null;
        let nodeSelection = null;
        let labelSelection = null;
        let linkSelection = null;
        let zoomBehavior = null;
        let initialMessageVisible = true;

        function drag(simulation) {
             function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
            function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
            function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }
        // Levenshtein Distance Function
        function levenshteinDistance(a, b) {
            if (a.length === 0) return b.length; 
            if (b.length === 0) return a.length;
                
            const matrix = [];

            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    const cost = a[j - 1] === b[i - 1] ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1,   
                        matrix[i][j - 1] + 1,     
                        matrix[i - 1][j - 1] + cost 
                    );
                }
            }

            return matrix[b.length][a.length];
        }


        async function fetchWikipediaDescription(personName) {
            const encodedName = encodeURIComponent(personName); const url = `https://simple.wikipedia.org/w/api.php?action=query&format=json&prop=extracts&exintro=true&explaintext=true&titles=${encodedName}&origin=*&redirects=1`;
            try { const response = await fetch(url); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); const pages = data.query.pages; const pageId = Object.keys(pages)[0]; if (pageId === "-1") { return "No description found on Simple Wikipedia."; } const extract = pages[pageId].extract; return extract ? extract.substring(0, 200) + (extract.length > 200 ? '...' : '') : "No description found."; } catch (error) { console.error("Error fetching Wikipedia description:", error); return "Could not fetch description."; }
        }

        function calculateDistributionBins() {
            const allDegrees = Array.from(inDegrees.values());
            const uniqueDegrees = Array.from(fullNodesMap.keys()).length;

            let lastUpper = -1;
            distributionData = [];

            for (const upper of DISTRIBUTION_BINS) {
                const lower = lastUpper + 1;
                const count = allDegrees.filter(d => d >= lower && d <= upper).length;
                
                let rangeLabel = `${lower}-${upper}`;
                if (upper === 0) rangeLabel = '0';
                if (lower === 1001) rangeLabel = '1000+';

                if (lower <= 1000) { 
                    distributionData.push({ range: rangeLabel, count: count, upperLimit: upper, lowerLimit: lower });
                }
                lastUpper = upper;
            }
            
            const finalLower = 1001;
            const finalCount = allDegrees.filter(d => d >= finalLower).length;
            if (finalCount > 0) {
                 distributionData.push({ range: '1000+', count: finalCount, upperLimit: Infinity, lowerLimit: finalLower });
            }

            distributionData = distributionData.filter(d => d.count > 0 || d.lowerLimit === 0);
        }
        
        function drawDistributionChart(personName, personInDegree) {
            const chartDiv = d3.select('#stats-chart-area');
            chartDiv.html('');

            const chartWidth = 280;
            const chartHeight = 120; 
            const padding = { top: 5, right: 5, bottom: 50, left: 5 }; 
            
            if (distributionData.length === 0) {
                chartDiv.text("Distribution data not ready.");
                return;
            }

            const svgChart = chartDiv.append("svg")
                .attr("width", chartWidth)
                .attr("height", chartHeight)
                .style("background", "transparent");

            const innerWidth = chartWidth - padding.left - padding.right;
            const innerHeight = chartHeight - padding.top - padding.bottom;
            
            const g = svgChart.append("g")
                .attr("transform", `translate(${padding.left}, ${padding.top})`);


            const xScale = d3.scaleBand()
                .domain(distributionData.map(d => d.range))
                .range([0, innerWidth])
                .padding(0.1);

            const maxY = d3.max(distributionData, d => d.count);

            const yScale = d3.scaleLinear()
                .domain([0, maxY])
                .range([innerHeight, 0]);


            const xAxisGroup = g.append("g")
                .attr("transform", `translate(0, ${innerHeight})`)
                .call(d3.axisBottom(xScale).tickSize(0).tickPadding(5));
                
            xAxisGroup.selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-65)")
                .attr("fill", "#ccc")
                .attr("font-size", "7px")
                .attr("font-family", "'Press Start 2P', cursive");
            
            g.append("line")
                .attr("x1", 0)
                .attr("y1", innerHeight)
                .attr("x2", 0)
                .attr("y2", 0)
                .attr("stroke", "#aaa")
                .attr("stroke-width", 0.5);
                
            g.selectAll(".bar")
                .data(distributionData)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => xScale(d.range))
                .attr("y", d => yScale(d.count))
                .attr("width", xScale.bandwidth())
                .attr("height", d => innerHeight - yScale(d.count))
                .attr("fill", "#444");
            
            const currentBin = distributionData.find(d => personInDegree >= d.lowerLimit && personInDegree <= d.upperLimit);
            
            if (currentBin) {
                const xCenter = xScale(currentBin.range) + xScale.bandwidth() / 2;
                
                g.append("circle")
                    .attr("cx", xCenter)
                    .attr("cy", yScale(currentBin.count) - 5)
                    .attr("r", 4)
                    .attr("fill", nodeColors.root)
                    .attr("stroke", "#1a1a1a")
                    .attr("stroke-width", 2)
                    .append("title")
                    .text(`${personName} (Mentions: ${personInDegree})`);
                    
                g.append("line")
                    .attr("x1", xCenter)
                    .attr("y1", innerHeight)
                    .attr("x2", xCenter)
                    .attr("y2", yScale(currentBin.count) - 5)
                    .attr("stroke", nodeColors.root)
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "2,2");
                    
            }
        }

        d3.json("https://pub-dd5f169084714d5980ce7c150880d0a6.r2.dev/full_graph.json").then(graph => {
            console.log("Full graph data loaded.");
            loadingText.style("display", "none");
            fullGraphData = graph;

            console.log("Pre-processing graph data...");
            allNodeNames = [];
            fullGraphData.nodes.forEach(n => {
                fullNodesMap.set(n.id, n); allNodeNames.push(n.id); inDegrees.set(n.id, 0); outDegrees.set(n.id, 0);
             });
            fullGraphData.links.forEach(l => {
                const sourceId = typeof l.source === 'object' && l.source !== null ? l.source.id : l.source;
                const targetId = typeof l.target === 'object' && l.target !== null ? l.target.id : l.target;
                if (sourceId && targetId && fullNodesMap.has(sourceId) && fullNodesMap.has(targetId)) {
                    if (!fullAdj.has(sourceId)) fullAdj.set(sourceId, new Set()); if (!fullRevAdj.has(targetId)) fullRevAdj.set(targetId, new Set());
                    fullAdj.get(sourceId).add(targetId); fullRevAdj.get(targetId).add(sourceId);
                    outDegrees.set(sourceId, (outDegrees.get(sourceId) || 0) + 1); inDegrees.set(targetId, (inDegrees.get(targetId) || 0) + 1);
                }
             });
            rankedNodes = Array.from(inDegrees.entries())
                .map(([id, degree]) => ({ id, inDegree: degree }))
                .sort((a, b) => b.inDegree - a.inDegree);
            
            calculateDistributionBins(); ư

            displayLeaderboard();
            console.log("Pre-processing complete.");

            setupSimulation();
            updateGraph(defaultRoot);
            initialMessageVisible = true;

            explanationToggle.on('click', () => {
                const isExpanded = explanationContent.style('display') === 'block'; explanationContent.style('display', isExpanded ? 'none' : 'block'); explanationContainer.classed('expanded', !isExpanded);
             });
             
            d3.select('#stats-toggle').on('click', () => {
                 statsContainer.classed('collapsed', !statsContainer.classed('collapsed'));
             });

            d3.select('#leaderboard-toggle').on('click', () => {
                 leaderboardContainer.classed('collapsed', !leaderboardContainer.classed('collapsed'));
             });

            d3.select('#randomize-button').on('click', () => {
	            if (typeof gtag === 'function') {
		            gtag('event', 'randomize');
	            }

	            if (allNodeNames && allNodeNames.length > 0) { 
		            const randomIndex = Math.floor(Math.random() * allNodeNames.length); 
		            const randomName = allNodeNames[randomIndex]; 
		            searchInput.value = randomName; 
		            updateGraph(randomName); 
	            } else { 
		            searchMessage.text("Data not loaded yet for randomize."); 
	            }
            });
        }).catch(error => { 
            console.error("Error loading full graph data:", error);
            loadingText.text("Error: Could not load full_graph.json.");
         });

        function displayLeaderboard() {
            leaderboardListOl.html(''); 
            const topN = rankedNodes.slice(0, LEADERBOARD_SIZE);
            
            topN.forEach((node, index) => { 
                const listItem = leaderboardListOl.append('li');
                
                listItem.on('click', () => {
                    searchInput.value = node.id;
                    updateGraph(node.id);
                });

                listItem.text(`${index + 1}. ${node.id}`)
                    .style('cursor', 'pointer')
                    .append('span')
                    .text(`(${node.inDegree})`);
            });
        }

        function setupSimulation() {
            simulationInstance = d3.forceSimulation() .force("link", d3.forceLink().id(d => d.id).distance(100)) .force("charge", d3.forceManyBody().strength(-250)) .force("center", d3.forceCenter(width / 2, height / 2)) .on("tick", ticked);
         }

         function setupZoom() {
            zoomBehavior = d3.zoom() .extent([[0, 0], [width, height]]) .scaleExtent([0.1, 8]) .on("zoom", ({ transform }) => { const mainGroup = svg.select("g"); if (mainGroup.node()) mainGroup.attr("transform", transform); }); svg.call(zoomBehavior);
          }
          
        async function updateGraph(rootPersonName) { 
        
        if (!initialMessageVisible) { initialMessageDiv.text(""); } initialMessageVisible = false;
        searchLoading.style('display', 'inline'); searchMessage.text('');
        statsContentDiv.html("Loading stats..."); statsDescriptionDiv.html("Fetching description...");

        if (rootPersonName.toLowerCase() === 'rick astley') {
        searchLoading.style('display', 'none'); 
	    window.location.href = RICK_ROLL_URL; 
	    return;
        }

        if (rootPersonName.toLowerCase() === 'the frog society') { 
	        if (typeof gtag === 'function') {
	            gtag('event', 'found_easter_egg', { 'easter_egg_name': 'the frog society' });
	        }
	        searchMessage.text("he is too shy to be on wikipedia but he wants you to know that he loves you for remembering him <3"); 
            searchLoading.style('display', 'none'); 
	        svg.selectAll("g").remove(); 
	        statsContentDiv.html(''); 
	        statsDescriptionDiv.html(''); 
            return;
        }

        if (rootPersonName.toLowerCase() === 'huyenthefabulous') { 
	        if (typeof gtag === 'function') {
	            gtag('event', 'found_easter_egg', { 'easter_egg_name': 'huyenthefabulous' });
            }
	            
            searchMessage.text("hi u :))))"); 
	        searchLoading.style('display', 'none'); 
	        svg.selectAll("g").remove(); 
            statsContentDiv.html(''); 
	        statsDescriptionDiv.html(''); 
	        return;
        }
       
        let actualRootName = rootPersonName; let found = false; const lowerCaseName = rootPersonName.toLowerCase();
        for (const key of fullNodesMap.keys()) { if (key.toLowerCase() === lowerCaseName) { actualRootName = key; found = true; break; } }

        if (!found) { 
            let minDistance = Infinity;
            let suggestion = null;
            const lowerCaseInput = rootPersonName.toLowerCase();

            if (allNodeNames && allNodeNames.length > 0) {
                for (const name of allNodeNames) {
                    const dist = levenshteinDistance(lowerCaseInput, name.toLowerCase());
                    if (dist < minDistance) {
                        minDistance = dist;
                        suggestion = name;
                    }
                }
            }

            console.log(`Input: '${rootPersonName}', Closest match: '${suggestion}', Distance: ${minDistance}`);

            if (suggestion && minDistance <= SUGGESTION_THRESHOLD) {
                    
                searchMessage.html(`'${rootPersonName}' not found. Did you mean: <a id="suggestion-link">${suggestion}</a>?`);
                
                d3.select('#suggestion-link').on('click', () => {
                    document.getElementById('search-input').value = suggestion;
                    updateGraph(suggestion); 
                });

            } else {
                searchMessage.text(`'${rootPersonName}' not found.`);
            }

            searchLoading.style('display', 'none'); 
            statsContentDiv.html(''); 
            statsDescriptionDiv.html(''); 
            return;
        }


        rootPersonName = actualRootName; 

        const description = await fetchWikipediaDescription(rootPersonName); 

        setTimeout(() => { 
            if (!fullGraphData) { searchMessage.text('Graph data not loaded.'); searchLoading.style('display', 'none'); return; }

            console.log(`Updating graph for root: ${rootPersonName}`);

            const personInDegree = inDegrees.get(rootPersonName) || 0; const personOutDegree = outDegrees.get(rootPersonName) || 0; const personRank = rankedNodes.findIndex(node => node.id === rootPersonName) + 1;
            statsContentDiv.html(`<b>${rootPersonName}</b><br>Mentions: ${personOutDegree}<br>Mentioned By: ${personInDegree}<br>Rank: ${personRank} / ${rankedNodes.length}`);
            statsDescriptionDiv.text(description);
                
            drawDistributionChart(rootPersonName, personInDegree);

            const outNeighbors = fullAdj.get(rootPersonName) || new Set(); const inNeighbors = fullRevAdj.get(rootPersonName) || new Set(); const allNeighborIds = new Set([...outNeighbors, ...inNeighbors]);

            const subgraphNodeIds = new Set([rootPersonName, ...allNeighborIds]);
            const subgraphNodes = Array.from(subgraphNodeIds).map(id => { const originalNode = fullNodesMap.get(id); let group = "unknown"; if (id === rootPersonName) { group = "root"; } else { const linksToRoot = inNeighbors.has(id); const linkedFromRoot = outNeighbors.has(id); if (linksToRoot && linkedFromRoot) group = "mutual_neighbor"; else if (linksToRoot) group = "in_neighbor"; else if (linkedFromRoot) group = "out_neighbor"; } return { id: id, url: originalNode?.url, group: group }; });
            const subgraphNodesMap = new Map(subgraphNodes.map(n => [n.id, n]));

            let subgraphLinks = []; const linkSet = new Set();
            subgraphNodes.forEach(sourceNode => { const sourceId = sourceNode.id; const targetsInFullGraph = fullAdj.get(sourceId) || new Set(); targetsInFullGraph.forEach(targetId => { if (subgraphNodesMap.has(targetId)) { const targetNode = subgraphNodesMap.get(targetId); linkSet.add(`${sourceId}->${targetId}`); subgraphLinks.push({ source: sourceNode, target: targetNode, type: 'potential_oneway' }); } }); });
            subgraphLinks = subgraphLinks.map(link => { const sourceId = typeof link.source === 'object' ? link.source.id : link.source; const targetId = typeof link.target === 'object' ? link.target.id : link.target; let finalType = 'oneway'; if (linkSet.has(`${targetId}->${sourceId}`)) { if (sourceId === rootPersonName || targetId === rootPersonName) finalType = 'mutual_root'; else finalType = 'mutual_neighbor'; } else { if (sourceId === rootPersonName || targetId === rootPersonName) finalType = 'oneway_root'; else finalType = 'oneway_neighbor'; } return { ...link, type: finalType }; });

            console.log(`Subgraph: ${subgraphNodes.length} nodes, ${subgraphLinks.length} links.`);

            svg.selectAll("g").remove(); const g = svg.append("g"); if (zoomBehavior) { svg.call(zoomBehavior); svg.call(zoomBehavior.transform, d3.zoomIdentity); }
            linkSelection = g.append("g").attr("class", "links").selectAll("line").data(subgraphLinks).join("line") .attr("stroke-width", 1) .attr("class", d => d.type.includes('oneway') ? "oneway" : null); // Apply .oneway class for styling
            nodeGroupSelection = g.append("g").attr("class", "nodes-and-labels").selectAll("g").data(subgraphNodes, d => d.id).join("g");
            nodeSelection = nodeGroupSelection.append("circle").attr("class", "node-circle") .attr("fill", d => nodeColors[d.group] || "#ccc") .attr("r", d => d.group === 'root' ? 10 : 5) .call(drag(simulationInstance)) .on("mouseover", handleMouseOver).on("mousemove", handleMouseMove).on("mouseout", handleMouseOut).on("dblclick", handleDoubleClick);
            labelSelection = nodeGroupSelection.append("text").text(d => d.id) .attr('x', 0).attr('y', d => (d.group === 'root' ? 10 : 5) + 12);
            simulationInstance.nodes(subgraphNodes); simulationInstance.force("link").links(subgraphLinks); simulationInstance.alpha(1).restart();
            searchLoading.style('display', 'none'); console.log("Graph update complete.");
        }, 50); 
        }

        function ticked() {
            if (linkSelection && linkSelection.nodes().length > 0) { linkSelection .attr("x1", d => d.source?.x || 0) .attr("y1", d => d.source?.y || 0) .attr("x2", d => d.target?.x || 0) .attr("y2", d => d.target?.y || 0); }
           if (nodeGroupSelection && nodeGroupSelection.nodes().length > 0) { nodeGroupSelection.attr("transform", d => `translate(${d.x || width/2},${d.y || height/2})`); }
        }

        function handleMouseOver(event, d) { 
            tooltip.style("opacity", 1).html(d.id); 
    
            if (nodeSelection) {
                const neighborIds = new Set();
                if (fullAdj.has(d.id)) {
                    fullAdj.get(d.id).forEach(id => neighborIds.add(id));
                }
                if (fullRevAdj.has(d.id)) {
                    fullRevAdj.get(d.id).forEach(id => neighborIds.add(id));
                }
                neighborIds.add(d.id); 

                nodeSelection.style('opacity', n => neighborIds.has(n.id) ? 1.0 : 0.1);
                labelSelection.style('opacity', l => neighborIds.has(l.id) ? 1.0 : 0.1);
        
                linkSelection.style('stroke-opacity', l => {
                    const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                    const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                    return (sourceId === d.id || targetId === d.id) ? 0.7 : 0.05;
                });
            }

            d3.select(this).transition().duration(100).attr("r", d.group === 'root' ? 15 : 10); 
        }

        function handleMouseMove(event) { 
            tooltip.style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 28) + "px"); 
        }

        function handleMouseOut(event, d) { 
            tooltip.style("opacity", 0); 
    
            if (nodeSelection) {
                nodeSelection.style('opacity', 1.0);
                labelSelection.style('opacity', 1.0);
                linkSelection.style('stroke-opacity', l => l.type.includes('oneway') ? 0.4 : 0.7); 
            }

            d3.select(this).transition().duration(100).attr("r", d.group === 'root' ? 10 : 5); 
        }

        function handleDoubleClick(event, d) { 
	        if (typeof gtag === 'function') {
		        gtag('event', 'view_person_details', { 'person_name': d.id });
	        }

	        if (d.url) window.open(d.url, '_blank'); 
	        else console.warn("Node clicked, but no URL found:", d); 
        }

        const searchInput = document.getElementById('search-input');
        const searchButton = d3.select('#search-button');

        searchButton.on('click', () => { 
	        const searchTerm = searchInput.value.trim(); 
	        if (searchTerm) {
		        if (typeof gtag === 'function') {
			        gtag('event', 'search', { 'search_term': searchTerm });
		        }
		        updateGraph(searchTerm); 
	        }
        });
	
        searchInput.addEventListener('keypress', function(event) { 
	        if (event.key === 'Enter') { 
		        const searchTerm = searchInput.value.trim(); 
		        if (searchTerm) {
			        if (typeof gtag === 'function') {
				        gtag('event', 'search', { 'search_term': searchTerm });
			        }
			        updateGraph(searchTerm); 
		        }
	        } 
        });
        explanationToggle.on('click', () => {
             const isExpanded = explanationContent.style('display') === 'block'; explanationContent.style('display', isExpanded ? 'none' : 'block'); explanationContainer.classed('expanded', !isExpanded);
         });

        function toggleContainer(id) {
            const container = d3.select('#' + id);
            container.classed('collapsed', !container.classed('collapsed'));
        }

        window.toggleContainer = toggleContainer;


    </script>
</body>
</html>
