<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WikiPeople Graph</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Import Pixel Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        /* Apply Pixel Font */
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            background-color: #201515;
            color: #ccc; /* Default text color */
        }
        /* Graph Styles */
        .links line { stroke: #d8ff4d; stroke-opacity: 0.7; }
        .links line.oneway { stroke: #999; stroke-dasharray: 4,4; stroke-opacity: 0.4; }
        .node-circle { stroke: #fff; stroke-width: 1.5px; cursor: pointer; }
        .nodes-and-labels g text { fill: #ccc; font-size: 10px; pointer-events: none; text-anchor: middle; font-family: 'Press Start 2P', cursive; }
        /* Tooltip */
        #tooltip { position: absolute; opacity: 0; background-color: #333; color: white; padding: 8px 12px; border-radius: 6px; pointer-events: none; transition: opacity 0.2s; font-size: 0.875rem; font-family: sans-serif; }
        /* Search Area */
        #search-container { position: absolute; top: 10px; left: 10px; z-index: 10; }
        #search-button, #randomize-button { /* Apply styles to both buttons */
            background-color: #d8ff4d; color: #1a1a1a; transition: background-color 0.2s;
            font-family: 'Press Start 2P', cursive; padding-top: 6px; padding-bottom: 6px;
            font-size: 14px; margin-left: 8px;
        }
        #search-button:hover, #randomize-button:hover { background-color: #b8cc3d; }
        #search-input { font-family: 'Press Start 2P', cursive; font-size: 14px; width: 350px; }
        #search-loading { display: none; margin-left: 10px; font-style: normal; color: #aaa; font-size: 10px;}
        #search-message, #initial-message { font-family: 'Press Start 2P', cursive; font-size: 8px; margin-top: 4px; min-height: 1.2em; }
        #search-message a { color: #61dafb; text-decoration: underline; cursor: pointer; }
        #search-message a:hover { color: #fff; }

        /* Stats Display Area */
        #stats-container {
            position: absolute; top: 10px; right: 10px; background-color: rgba(40, 40, 40, 0.8);
            padding: 10px; border-radius: 8px; z-index: 10; font-size: 10px; line-height: 1.4;
            min-width: 200px; max-width: 300px; color: #eee; font-family: 'Press Start 2P', cursive;
            transition: height 0.3s ease-out;
            height: auto;
        }
        #stats-container h3 { 
            font-size: 12px; margin-bottom: 5px; color: #d8ff4d; border-bottom: 1px solid #555; padding-bottom: 3px;
            cursor: pointer; user-select: none;
        }
        #stats-container.collapsed {
            height: 35px;
            overflow: hidden;
            padding-bottom: 5px;
        }
        /* Style for the description */
         #stats-description {
             margin-top: 8px; font-size: 9px; color: #bbb; border-top: 1px solid #555; padding-top: 5px;
             max-height: 120px; overflow-y: auto;
         }
        /* Chart Area Styling */
        #stats-chart-area {
            margin-top: 10px;
            padding-top: 5px;
            border-top: 1px solid #555;
            padding-bottom: 5px; 
        }
        /* Leaderboard Area */
        #leaderboard-container {
            position: absolute; bottom: 10px; left: 10px; background-color: rgba(40, 40, 40, 0.8);
            padding: 10px; border-radius: 8px; z-index: 10; font-size: 10px; line-height: 1.4;
            max-height: 30vh; color: #eee; font-family: 'Press Start 2P', cursive;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        #leaderboard-container.collapsed {
            max-height: 35px;
            overflow: hidden;
        }
        #leaderboard-container h3 { 
            font-size: 12px; margin-bottom: 5px; color: #d8ff4d; border-bottom: 1px solid #555; padding-bottom: 3px;
            cursor: pointer; user-select: none;
        }
         #leaderboard-container ol { list-style-position: inside; padding-left: 0; }
         #leaderboard-container li { margin-bottom: 2px; }
         #leaderboard-container li span { color: #aaa; margin-left: 5px; }

         /* Loading Text */
         #loading { font-family: 'Press Start 2P', cursive; }
         /* Footer Attribution */
         #footer-attribution {
             position: absolute; bottom: calc(30vh + 25px); left: 10px; font-size: 8px; color: #777; z-index: 5; font-family: 'Press Start 2P', cursive;
         }
         /* Explanation Area */
         #explanation-container {
            position: absolute; bottom: 10px; right: 10px; background-color: rgba(40, 40, 40, 0.8);
            padding: 10px; border-radius: 8px; z-index: 10; font-size: 10px; line-height: 1.4;
            max-width: 250px; color: #eee; font-family: 'Press Start 2P', cursive;
         }
         #explanation-toggle { font-size: 12px; margin-bottom: 5px; color: #aaa; cursor: pointer; border-bottom: 1px solid #555; padding-bottom: 3px; user-select: none; }
         #explanation-toggle::after { content: ' [+]'; font-size: 10px; }
         #explanation-container.expanded #explanation-toggle::after { content: ' [-]'; }
         #explanation-content { display: none; margin-top: 5px; }


    </style>
</head>
<body class="h-full text-gray-100">

    
    <!-- Search UI -->
    <div id="search-container">
        <input type="text" id="search-input" placeholder="Enter root person..." class="px-2 py-1 rounded border border-gray-600 bg-gray-700 text-white focus:outline-none focus:border-blue-500">
        <button id="search-button" class="px-3 py-1 rounded font-semibold">Visualize</button>
        <!-- Randomize Button added back -->
        <button id="randomize-button" class="px-3 py-1 rounded font-semibold">Randomize</button>
        <span id="search-loading">Processing...</span>
        <div id="initial-message" class="text-xs text-red-400 mt-1 h-4">
            <!-- Initial message will be added/removed by JS -->
        </div>
        <div id="search-message" class="text-xs text-lime-400 mt-1 h-4"></div> <!-- Changed color for frog message -->
    </div>

    <!-- Stats Display -->
    <div id="stats-container">
        <!-- Added inline onclick for robust toggling -->
        <h3 onclick="toggleContainer('stats-container')">Person Statistics</h3>
        <div id="stats-content">Select a person...</div>
        <!-- NEW CHART AREA -->
        <div id="stats-chart-area"></div> 
        <!-- Added div for description -->
        <div id="stats-description"></div>
    </div>

    <!-- Footer Attribution Line (Updated text and moved to clear search area) -->
    <div id="footer-attribution">
        WikiPeople - a product made by Duy Le aka the frog society
    </div>

     <!-- Leaderboard Display -->
    <div id="leaderboard-container">
        <!-- Added inline onclick for robust toggling -->
        <h3 onclick="toggleContainer('leaderboard-container')">Top Mentions</h3>
        <ol id="leaderboard-list"><li>Loading...</li></ol>
    </div>


    <svg id="graph-viz" class="w-full h-full"></svg>
    <div id="tooltip"></div>
    <div id="loading" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-xl md:text-2xl">
        Loading full_graph.json...
    </div>

    <!-- Explanation Box -->
    <div id="explanation-container">
        <h3 id="explanation-toggle">Graph Logic</h3>
        <!-- CORRECTED Explanation Text -->
        <div id="explanation-content">
            Shows searched person (root) & everyone they link to OR who links to them.
            <br><br>
            - <span style="color:#d8ff4d"><b>Solid Lines:</b></span> Mutual link (A ↔ B).
            <br>
            - <span style="color:#999"><b>Dotted Lines:</b></span> One-way link (A → B, but B <span style="text-decoration: line-through;">↔</span> A in subgraph).
            <br><br>
            Node colors show relationship to current root:
            <br>
            <span style="color:#d8ff4d">Root</span>, <!-- Lime -->
            <span style="color:#ff7f0e">Mutual</span>, <!-- Orange -->
            <span style="color:#2ca02c">Links To Root</span>, <!-- Dark Green -->
            <span style="color:#1f77b4">Linked By Root</span>. <!-- Blue -->
        </div>
    </div>


    <script>
        // --- Globals ---
        const svg = d3.select("#graph-viz");
        const loadingText = d3.select("#loading");
        const width = +svg.node().getBoundingClientRect().width;
        const height = +svg.node().getBoundingClientRect().height;
        const tooltip = d3.select("#tooltip");
        const searchLoading = d3.select("#search-loading");
        const searchMessage = d3.select('#search-message');
        const initialMessageDiv = d3.select('#initial-message');
        const statsContentDiv = d3.select('#stats-content');
        const leaderboardListOl = d3.select('#leaderboard-list');
        const explanationContainer = d3.select('#explanation-container');
        const explanationToggle = d3.select('#explanation-toggle');
        const explanationContent = d3.select('#explanation-content');
        const randomizeButton = d3.select('#randomize-button');
        const statsDescriptionDiv = d3.select('#stats-description');
        const statsContainer = d3.select('#stats-container');
        const leaderboardContainer = d3.select('#leaderboard-container');


        const nodeColors = {
            "root": "#d8ff4d",           // Current searched person (Lime Green)
            "mutual_neighbor": "#ff7f0e", // Links both ways with root (Orange)
            "in_neighbor": "#2ca02c",    // Links TO root only (Dark Green)
            "out_neighbor": "#1f77b4"     // Linked FROM root only (Blue)
         };
        const defaultRoot = "Michael Stevens"; // Default root
        const LEADERBOARD_SIZE = 10;
        const SUGGESTION_THRESHOLD = 3; // Max Levenshtein distance for suggestions
        const RICK_ROLL_URL = "https://www.youtube.com/watch?v=dQw4w9WgXcQ"; // Rick Roll URL
        const DISTRIBUTION_BINS = [0, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000];
        
        let fullGraphData = null;
        let fullNodesMap = new Map();
        let fullAdj = new Map();
        let fullRevAdj = new Map();
        let inDegrees = new Map();
        let outDegrees = new Map();
        let rankedNodes = [];
        let allNodeNames = []; // Store all names for suggestion calculation
        let distributionData = []; // Global storage for histogram bins

        let simulationInstance = null;
        let nodeGroupSelection = null;
        let nodeSelection = null;
        let labelSelection = null;
        let linkSelection = null;
        let zoomBehavior = null;
        let initialMessageVisible = true;


        // --- Levenshtein Distance Function ---
        function levenshteinDistance(a, b) {
            if (a.length === 0) return b.length; if (b.length === 0) return a.length;
            const matrix = []; for (let i = 0; i <= b.length; i++) matrix[i] = [i]; for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
            for (let i = 1; i <= b.length; i++) { for (let j = 1; j <= a.length; j++) {
                const cost = a[j - 1] === b[i - 1] ? 0 : 1;
                matrix[i][j] = Math.min( matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost ); } }
            return matrix[b.length][a.length];
        }


        // --- Drag Functions ---
        function drag(simulation) {
             function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
            function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
            function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        // --- Fetch Wikipedia Description Function ---
        async function fetchWikipediaDescription(personName) {
            const encodedName = encodeURIComponent(personName); const url = `https://simple.wikipedia.org/w/api.php?action=query&format=json&prop=extracts&exintro=true&explaintext=true&titles=${encodedName}&origin=*&redirects=1`;
            try { const response = await fetch(url); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); const pages = data.query.pages; const pageId = Object.keys(pages)[0]; if (pageId === "-1") { return "No description found on Simple Wikipedia."; } const extract = pages[pageId].extract; return extract ? extract.substring(0, 200) + (extract.length > 200 ? '...' : '') : "No description found."; } catch (error) { console.error("Error fetching Wikipedia description:", error); return "Could not fetch description."; }
        }

        // --- Distribution Calculation Function (Runs Once) ---
        function calculateDistributionBins() {
            const allDegrees = Array.from(inDegrees.values());
            const uniqueDegrees = Array.from(fullNodesMap.keys()).length;

            let lastUpper = -1;
            distributionData = [];

            for (const upper of DISTRIBUTION_BINS) {
                const lower = lastUpper + 1;
                const count = allDegrees.filter(d => d >= lower && d <= upper).length;
                
                let rangeLabel = `${lower}-${upper}`;
                if (upper === 0) rangeLabel = '0';
                if (lower === 1001) rangeLabel = '1000+';

                if (lower <= 1000) { // Limit explicit bins to 1000
                    distributionData.push({ range: rangeLabel, count: count, upperLimit: upper, lowerLimit: lower });
                }
                lastUpper = upper;
            }
            
            // Add final catch-all bin for degrees > 1000
            const finalLower = 1001;
            const finalCount = allDegrees.filter(d => d >= finalLower).length;
            if (finalCount > 0) {
                 distributionData.push({ range: '1000+', count: finalCount, upperLimit: Infinity, lowerLimit: finalLower });
            }

            // Remove zero-count bins to keep chart clean, except for the 0-mention bin
            distributionData = distributionData.filter(d => d.count > 0 || d.lowerLimit === 0);
        }
        
        // --- Distribution Drawing Function (Runs on Search) ---
        function drawDistributionChart(personName, personInDegree) {
            const chartDiv = d3.select('#stats-chart-area');
            chartDiv.html(''); // Clear previous chart

            const chartWidth = 280;
            const chartHeight = 120; // Increased height
            const padding = { top: 5, right: 5, bottom: 50, left: 5 }; // Reduced left padding to 5, increased bottom to 50
            
            if (distributionData.length === 0) {
                chartDiv.text("Distribution data not ready.");
                return;
            }

            const svgChart = chartDiv.append("svg")
                .attr("width", chartWidth)
                .attr("height", chartHeight)
                .style("background", "transparent");

            const innerWidth = chartWidth - padding.left - padding.right;
            const innerHeight = chartHeight - padding.top - padding.bottom;
            
            const g = svgChart.append("g")
                .attr("transform", `translate(${padding.left}, ${padding.top})`);


            // --- SCALES ---
            const xScale = d3.scaleBand()
                .domain(distributionData.map(d => d.range))
                .range([0, innerWidth])
                .padding(0.1);

            const maxY = d3.max(distributionData, d => d.count);

            const yScale = d3.scaleLinear()
                .domain([0, maxY])
                .range([innerHeight, 0]);


            // --- DRAW AXIS (Simplified & Fixed) ---
            // X-Axis (Labels)
            const xAxisGroup = g.append("g")
                .attr("transform", `translate(0, ${innerHeight})`)
                .call(d3.axisBottom(xScale).tickSize(0).tickPadding(5));
                
            // Apply font and rotation styles to prevent clipping
            xAxisGroup.selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-65)")
                .attr("fill", "#ccc")
                .attr("font-size", "7px")
                .attr("font-family", "'Press Start 2P', cursive");
            
            // Y-Axis (Count label) - Clean horizontal line only
            g.append("line")
                .attr("x1", 0)
                .attr("y1", innerHeight)
                .attr("x2", 0)
                .attr("y2", 0)
                .attr("stroke", "#aaa")
                .attr("stroke-width", 0.5);
                

            // --- DRAW BARS ---
            g.selectAll(".bar")
                .data(distributionData)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => xScale(d.range))
                .attr("y", d => yScale(d.count))
                .attr("width", xScale.bandwidth())
                .attr("height", d => innerHeight - yScale(d.count))
                .attr("fill", "#444");


            // --- DRAW CURRENT PERSON MARKER ---
            
            const currentBin = distributionData.find(d => personInDegree >= d.lowerLimit && personInDegree <= d.upperLimit);
            
            if (currentBin) {
                const xCenter = xScale(currentBin.range) + xScale.bandwidth() / 2;
                
                g.append("circle")
                    .attr("cx", xCenter)
                    .attr("cy", yScale(currentBin.count) - 5)
                    .attr("r", 4)
                    .attr("fill", nodeColors.root)
                    .attr("stroke", "#1a1a1a")
                    .attr("stroke-width", 2)
                    .append("title")
                    .text(`${personName} (Mentions: ${personInDegree})`);
                    
                g.append("line")
                    .attr("x1", xCenter)
                    .attr("y1", innerHeight)
                    .attr("x2", xCenter)
                    .attr("y2", yScale(currentBin.count) - 5)
                    .attr("stroke", nodeColors.root)
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "2,2");
                    
            }
        }


        // --- Fetch Wikipedia Description Function ---
        async function fetchWikipediaDescription(personName) {
            const encodedName = encodeURIComponent(personName); const url = `https://simple.wikipedia.org/w/api.php?action=query&format=json&prop=extracts&exintro=true&explaintext=true&titles=${encodedName}&origin=*&redirects=1`;
            try { const response = await fetch(url); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); const pages = data.query.pages; const pageId = Object.keys(pages)[0]; if (pageId === "-1") { return "No description found on Simple Wikipedia."; } const extract = pages[pageId].extract; return extract ? extract.substring(0, 200) + (extract.length > 200 ? '...' : '') : "No description found."; } catch (error) { console.error("Error fetching Wikipedia description:", error); return "Could not fetch description."; }
        }

        // --- Load Full Data & Pre-process ---
        d3.json("https://pub-dd5f169084714d5980ce7c150880d0a6.r2.dev/full_graph.json").then(graph => {
            console.log("Full graph data loaded.");
            loadingText.style("display", "none");
            fullGraphData = graph;

            console.log("Pre-processing graph data...");
            allNodeNames = [];
            fullGraphData.nodes.forEach(n => {
                fullNodesMap.set(n.id, n); allNodeNames.push(n.id); inDegrees.set(n.id, 0); outDegrees.set(n.id, 0);
             });
            fullGraphData.links.forEach(l => {
                const sourceId = typeof l.source === 'object' && l.source !== null ? l.source.id : l.source;
                const targetId = typeof l.target === 'object' && l.target !== null ? l.target.id : l.target;
                if (sourceId && targetId && fullNodesMap.has(sourceId) && fullNodesMap.has(targetId)) {
                    if (!fullAdj.has(sourceId)) fullAdj.set(sourceId, new Set()); if (!fullRevAdj.has(targetId)) fullRevAdj.set(targetId, new Set());
                    fullAdj.get(sourceId).add(targetId); fullRevAdj.get(targetId).add(sourceId);
                    outDegrees.set(sourceId, (outDegrees.get(sourceId) || 0) + 1); inDegrees.set(targetId, (inDegrees.get(targetId) || 0) + 1);
                }
             });
            rankedNodes = Array.from(inDegrees.entries())
                .map(([id, degree]) => ({ id, inDegree: degree }))
                .sort((a, b) => b.inDegree - a.inDegree);
            
            calculateDistributionBins(); // Calculate bins after degrees are final

            displayLeaderboard();
            console.log("Pre-processing complete.");

            setupSimulation();
            updateGraph(defaultRoot);
            initialMessageVisible = true;

            // --- ATTACH LISTENERS AFTER DOM/DATA IS READY ---
            explanationToggle.on('click', () => {
                const isExpanded = explanationContent.style('display') === 'block'; explanationContent.style('display', isExpanded ? 'none' : 'block'); explanationContainer.classed('expanded', !isExpanded);
             });
             
            d3.select('#stats-toggle').on('click', () => {
                 statsContainer.classed('collapsed', !statsContainer.classed('collapsed'));
             });

            d3.select('#leaderboard-toggle').on('click', () => {
                 leaderboardContainer.classed('collapsed', !leaderboardContainer.classed('collapsed'));
             });

             // Add Randomize Button Listener
             d3.select('#randomize-button').on('click', () => {
                 if (allNodeNames && allNodeNames.length > 0) { const randomIndex = Math.floor(Math.random() * allNodeNames.length); const randomName = allNodeNames[randomIndex]; searchInput.value = randomName; updateGraph(randomName); } else { searchMessage.text("Data not loaded yet for randomize."); }
             });


        }).catch(error => { /* Error Handling */
            console.error("Error loading full graph data:", error);
            loadingText.text("Error: Could not load full_graph.json.");
         });

        // --- Display Leaderboard ---
        function displayLeaderboard() {
            leaderboardListOl.html(''); const topN = rankedNodes.slice(0, LEADERBOARD_SIZE);
            topN.forEach((node, index) => { leaderboardListOl.append('li').text(`${index + 1}. ${node.id}`).append('span').text(`(${node.inDegree})`); });
        }

        // --- Simulation Setup ---
        function setupSimulation() {
            simulationInstance = d3.forceSimulation() .force("link", d3.forceLink().id(d => d.id).distance(100)) .force("charge", d3.forceManyBody().strength(-250)) .force("center", d3.forceCenter(width / 2, height / 2)) .on("tick", ticked);
         }

        // --- Zoom Setup ---
         function setupZoom() {
            zoomBehavior = d3.zoom() .extent([[0, 0], [width, height]]) .scaleExtent([0.1, 8]) .on("zoom", ({ transform }) => { const mainGroup = svg.select("g"); if (mainGroup.node()) mainGroup.attr("transform", transform); }); svg.call(zoomBehavior);
          }
          
        // --- Graph Update Function ---
        async function updateGraph(rootPersonName) { // Make the function async
            // Handle messages
             if (!initialMessageVisible) { initialMessageDiv.text(""); } initialMessageVisible = false;
            searchLoading.style('display', 'inline'); searchMessage.text('');
            statsContentDiv.html("Loading stats..."); statsDescriptionDiv.html("Fetching description...");

            // Rick Astley Easter Egg (Silent Redirect)
            if (rootPersonName.toLowerCase() === 'rick astley') {
                searchLoading.style('display', 'none'); window.location.href = RICK_ROLL_URL; return;
            }
            if (rootPersonName.toLowerCase() === 'the frog society') { /* Frog message */
                 searchMessage.text("he is too shy to be on wikipedia but he wants you to know that he loves you for remembering him <3"); searchLoading.style('display', 'none'); svg.selectAll("g").remove(); statsContentDiv.html(''); statsDescriptionDiv.html(''); return;
            }

            let actualRootName = rootPersonName; let found = false; const lowerCaseName = rootPersonName.toLowerCase();
            for (const key of fullNodesMap.keys()) { if (key.toLowerCase() === lowerCaseName) { actualRootName = key; found = true; break; } }

            if (!found) { /* Suggestion logic removed */
                 searchMessage.text(`'${rootPersonName}' not found.`);
                 searchLoading.style('display', 'none'); statsContentDiv.html(''); statsDescriptionDiv.html(''); return;
            }
            rootPersonName = actualRootName; // Use correct case

            const description = await fetchWikipediaDescription(rootPersonName); // Fetch description

            setTimeout(() => { // Allow UI update for description
                if (!fullGraphData) { searchMessage.text('Graph data not loaded.'); searchLoading.style('display', 'none'); return; }

                console.log(`Updating graph for root: ${rootPersonName}`);

                // Display Stats & Description (Reworded content)
                const personInDegree = inDegrees.get(rootPersonName) || 0; const personOutDegree = outDegrees.get(rootPersonName) || 0; const personRank = rankedNodes.findIndex(node => node.id === rootPersonName) + 1;
                // --- CORRECTED STATS DISPLAY ---
                statsContentDiv.html(`<b>${rootPersonName}</b><br>Mentions: ${personOutDegree}<br>Mentioned By: ${personInDegree}<br>Rank: ${personRank} / ${rankedNodes.length}`);
                // ---
                statsDescriptionDiv.text(description);
                
                // *** Draw Distribution Chart ***
                drawDistributionChart(rootPersonName, personInDegree);
                // ***

                // Find ALL Neighbors (Union)
                const outNeighbors = fullAdj.get(rootPersonName) || new Set(); const inNeighbors = fullRevAdj.get(rootPersonName) || new Set(); const allNeighborIds = new Set([...outNeighbors, ...inNeighbors]);

                // Build Subgraph Nodes (including root)
                const subgraphNodeIds = new Set([rootPersonName, ...allNeighborIds]);
                const subgraphNodes = Array.from(subgraphNodeIds).map(id => { const originalNode = fullNodesMap.get(id); let group = "unknown"; if (id === rootPersonName) { group = "root"; } else { const linksToRoot = inNeighbors.has(id); const linkedFromRoot = outNeighbors.has(id); if (linksToRoot && linkedFromRoot) group = "mutual_neighbor"; else if (linksToRoot) group = "in_neighbor"; else if (linkedFromRoot) group = "out_neighbor"; } return { id: id, url: originalNode?.url, group: group }; });
                const subgraphNodesMap = new Map(subgraphNodes.map(n => [n.id, n]));

                // Build Subgraph Links with Type
                let subgraphLinks = []; const linkSet = new Set();
                subgraphNodes.forEach(sourceNode => { const sourceId = sourceNode.id; const targetsInFullGraph = fullAdj.get(sourceId) || new Set(); targetsInFullGraph.forEach(targetId => { if (subgraphNodesMap.has(targetId)) { const targetNode = subgraphNodesMap.get(targetId); linkSet.add(`${sourceId}->${targetId}`); subgraphLinks.push({ source: sourceNode, target: targetNode, type: 'potential_oneway' }); } }); });
                 subgraphLinks = subgraphLinks.map(link => { const sourceId = typeof link.source === 'object' ? link.source.id : link.source; const targetId = typeof link.target === 'object' ? link.target.id : link.target; let finalType = 'oneway'; if (linkSet.has(`${targetId}->${sourceId}`)) { if (sourceId === rootPersonName || targetId === rootPersonName) finalType = 'mutual_root'; else finalType = 'mutual_neighbor'; } else { if (sourceId === rootPersonName || targetId === rootPersonName) finalType = 'oneway_root'; else finalType = 'oneway_neighbor'; } return { ...link, type: finalType }; });

                console.log(`Subgraph: ${subgraphNodes.length} nodes, ${subgraphLinks.length} links.`);

                // UPDATE D3 ELEMENTS
                svg.selectAll("g").remove(); const g = svg.append("g"); if (zoomBehavior) { svg.call(zoomBehavior); svg.call(zoomBehavior.transform, d3.zoomIdentity); }
                linkSelection = g.append("g").attr("class", "links").selectAll("line").data(subgraphLinks).join("line") .attr("stroke-width", 1) .attr("class", d => d.type.includes('oneway') ? "oneway" : null); // Apply .oneway class for styling
                nodeGroupSelection = g.append("g").attr("class", "nodes-and-labels").selectAll("g").data(subgraphNodes, d => d.id).join("g");
                nodeSelection = nodeGroupSelection.append("circle").attr("class", "node-circle") .attr("fill", d => nodeColors[d.group] || "#ccc") .attr("r", d => d.group === 'root' ? 10 : 5) .call(drag(simulationInstance)) .on("mouseover", handleMouseOver).on("mousemove", handleMouseMove).on("mouseout", handleMouseOut).on("dblclick", handleDoubleClick);
                labelSelection = nodeGroupSelection.append("text").text(d => d.id) .attr('x', 0).attr('y', d => (d.group === 'root' ? 10 : 5) + 12);
                // UPDATE SIMULATION
                simulationInstance.nodes(subgraphNodes); simulationInstance.force("link").links(subgraphLinks); simulationInstance.alpha(1).restart();
                searchLoading.style('display', 'none'); console.log("Graph update complete.");
            }, 50); // Keep small timeout
         }

        // --- Animation Tick Function ---
        function ticked() {
            if (linkSelection && linkSelection.nodes().length > 0) { linkSelection .attr("x1", d => d.source?.x || 0) .attr("y1", d => d.source?.y || 0) .attr("x2", d => d.target?.x || 0) .attr("y2", d => d.target?.y || 0); }
           if (nodeGroupSelection && nodeGroupSelection.nodes().length > 0) { nodeGroupSelection.attr("transform", d => `translate(${d.x || width/2},${d.y || height/2})`); }
        }

        // --- Event Handlers ---
        function handleMouseOver(event, d) { tooltip.style("opacity", 1).html(d.id); d3.select(this).transition().duration(100).attr("r", d.group === 'root' ? 15 : 10); }
        function handleMouseMove(event) { tooltip.style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 28) + "px"); }
        function handleMouseOut(event, d) { tooltip.style("opacity", 0); d3.select(this).transition().duration(100).attr("r", d.group === 'root' ? 10 : 5); }
        function handleDoubleClick(event, d) { if (d.url) window.open(d.url, '_blank'); else console.warn("Node clicked, but no URL found:", d); }

        // --- Search Event Listeners ---
        const searchInput = document.getElementById('search-input'); const searchButton = d3.select('#search-button');
        searchButton.on('click', () => { const searchTerm = searchInput.value.trim(); if (searchTerm) updateGraph(searchTerm); });
        searchInput.addEventListener('keypress', function(event) { if (event.key === 'Enter') { const searchTerm = searchInput.value.trim(); if (searchTerm) updateGraph(searchTerm); } });

        // --- Explanation Toggle Listener ---
        explanationToggle.on('click', () => {
             const isExpanded = explanationContent.style('display') === 'block'; explanationContent.style('display', isExpanded ? 'none' : 'block'); explanationContainer.classed('expanded', !isExpanded);
         });

        // --- Global Toggle Function (Used by inline onclicks) ---
        function toggleContainer(id) {
            const container = d3.select('#' + id);
            container.classed('collapsed', !container.classed('collapsed'));
        }

        // Make toggle function globally available (for HTML onclick)
        window.toggleContainer = toggleContainer;


    </script>
</body>

</html>
